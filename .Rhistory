colnames(result) <- c("Lag", "AC", "ARCH-LM", "p-value")
if (is.null(format)) {
result <- kableExtra::kable(result, format = "rst", align = c("c", "r", "c", "c" ),
caption = "ARCH test")
} else{
#format <- match.arg(format)
result <- kableExtra::kable(result, format = format,
align = c("c", "r", "c", "c" ),
booktable = T, booktabs = T,
caption = "ARCH test")
}
r.lags <- lags
r.ARCH.LM = LM_stats[lags]
r.p_value <- p_values[lags]
#cat(sprintf("ARCH test based on %s", series_name))
return(result)
invisible(list(
Lag = r.lags,
ARCH.LM = r.ARCH.LM,
"p-value"= r.p_value
))
} ; ARCH.test(rnorm(98), lags = 2)
p <- ARCH.test(rnorm(98), lags = 2)
p
list(p)
#' print(arch_results$last_lag)
#' }
#'
#' @seealso
#' \code{\link[FinTS]{ArchTest}} for the underlying ARCH LM test implementation.
#'
#' @importFrom FinTS ArchTest
#' @importFrom stats residuals
#' @importFrom kableExtra kable
#' @export
ARCH.test <- function(x, lags=10, format = NULL, round=3, demean=TRUE) {
if (is.vector(x) && isTRUE(demean)) {
# Store the name for display purposes
series_name <- deparse(substitute(x))
uhat <- (x-base::mean(x))^2
}else if (is.vector(x) && !isTRUE(demean)) {
series_name <- deparse(substitute(x))
uhat <- (x)^2
} else {
model.class <- class(x)[1]  # Get class of the model
# Extract residuals
uhat <- (switch(model.class,
"lm" = residuals(x),
"ardl" = residuals(x),
"dynlm" = residuals(x),
"arma" = residuals(x),
"ar" = residuals(x),
"dynardl" = x$model$residuals,
"MSM.lm" = MSwM::msmResid(x),
residuals(x)))^2  # Default to residuals() if class not matched
series_name <- "Model Residuals"
}
n <- length(uhat)
if (lags >= n) {
stop("lag must be less than the length of the series")
}
# Create vectors to store LM statistics and p-values
LM_stats <- numeric(lags)
p_values <- numeric(lags)
arch.test.Matrix <- stats::embed(x, lags)
# Calculate statistics for each lag from 1 to lag using FinTS::ArchTest
nlags <- 2:(lags+1)
for (p in nlags) {
matarch <- stats::embed(uhat, p)
arch.lm <- lm( matarch[,1]~matarch[,2:p] )
arch.lm.sum <- base::summary(arch.lm)
LM_stats[p] <- base::round(dim(arch.lm$model)[1]*arch.lm.sum$r.squared, round)
p_values[p] <- base::round(1 - stats::pchisq(LM_stats[p], df = dim(arch.lm.sum$coefficients)[1]-1 ), round)
}
arch.ac <- stats::acf(uhat, lag.max = lags, plot = FALSE)$acf
arch.ac <- base::round(arch.ac, round)
formatted_pvalues <- sapply(p_values, function(p) {
if (p < 0.001) {
"0.000"
} else {
format(round(p, round), nsmall = round)
}
})
# Create results matrix
result <- cbind(1:lags, arch.ac[-1], LM_stats[-1], formatted_pvalues[-1])
colnames(result) <- c("Lag", "AC", "ARCH-LM", "p-value")
if (is.null(format)) {
result_table <- kableExtra::kable(result, format = "rst", align = c("c", "r", "c", "c" ),
caption = "ARCH test")
} else{
#format <- match.arg(format)
result_table <- kableExtra::kable(result, format = format,
align = c("c", "r", "c", "c" ),
booktable = T, booktabs = T,
caption = "ARCH test")
}
# Extract statistics for the last lag
last_lag_stats <- list(
Lag = lags,
AC = arch.ac[lags+1],
ARCH.LM = LM_stats[lags],
p.value = p_values[lags]
)
# Return both the table and the last lag statistics
return(list(
table = result_table,
last_lag = last_lag_stats
))
}
p <- ARCH.test(rnorm(98), lags = 2)
p
#' ARCH.test(lm_model, lags = 5)
#' }
#'
#' @seealso
#' \code{\link[FinTS]{ArchTest}} for the underlying ARCH LM test implementation.
#'
#' @importFrom FinTS ArchTest
#' @importFrom stats residuals
#' @importFrom kableExtra kable
#' @export
ARCH.test <- function(x, lags=10, format = NULL, round=3, demean=TRUE) {
if (is.vector(x) && isTRUE(demean)) {
# Store the name for display purposes
series_name <- deparse(substitute(x))
uhat <- (x-base::mean(x))^2
}else if (is.vector(x) && !isTRUE(demean)) {
series_name <- deparse(substitute(x))
uhat <- (x)^2
} else {
model.class <- class(x)[1]  # Get class of the model
# Extract residuals
uhat <- (switch(model.class,
"lm" = residuals(x),
"ardl" = residuals(x),
"dynlm" = residuals(x),
"arma" = residuals(x),
"ar" = residuals(x),
"dynardl" = x$model$residuals,
"MSM.lm" = MSwM::msmResid(x),
residuals(x)))^2  # Default to residuals() if class not matched
series_name <- "Model Residuals"
}
n <- length(uhat)
if (lags >= n) {
stop("lag must be less than the length of the series")
}
# Create vectors to store LM statistics and p-values
LM_stats <- numeric(lags)
p_values <- numeric(lags)
arch.test.Matrix <- stats::embed(x, lags)
# Calculate statistics for each lag from 1 to lag using FinTS::ArchTest
nlags <- 2:(lags+1)
for (p in nlags) {
matarch <- stats::embed(uhat, p)
arch.lm <- lm( matarch[,1]~matarch[,2:p] )
arch.lm.sum <- base::summary(arch.lm)
LM_stats[p] <- base::round(dim(arch.lm$model)[1]*arch.lm.sum$r.squared, round)
p_values[p] <- base::round(1 - stats::pchisq(LM_stats[p], df = dim(arch.lm.sum$coefficients)[1]-1 ), round)
}
arch.ac <- stats::acf(uhat, lag.max = lags, plot = FALSE)$acf
arch.ac <- base::round(arch.ac, round)
formatted_pvalues <- sapply(p_values, function(p) {
if (p < 0.001) {
"0.000"
} else {
format(round(p, round), nsmall = round)
}
})
# Create results matrix
result <- cbind(1:lags, arch.ac[-1], LM_stats[-1], formatted_pvalues[-1])
colnames(result) <- c("Lag", "AC", "ARCH-LM", "p-value")
if (is.null(format)) {
result <- kableExtra::kable(result, format = "rst", align = c("c", "r", "c", "c" ),
caption = "ARCH test")
} else{
#format <- match.arg(format)
result <- kableExtra::kable(result, format = format,
align = c("c", "r", "c", "c" ),
booktable = T, booktabs = T,
caption = "ARCH test")
}
#cat(sprintf("ARCH test based on %s", series_name))
invisible_stats <- list(
Lag = lags,
AC = arch.ac[lags+1],
ARCH.LM = LM_stats[lags],
p.value = p_values[lags]
)
class(result) <- "htest"
return(result)
} ; ARCH.test(rnorm(98), lags = 2)
#' ARCH.test(lm_model, lags = 5)
#' }
#'
#' @seealso
#' \code{\link[FinTS]{ArchTest}} for the underlying ARCH LM test implementation.
#'
#' @importFrom FinTS ArchTest
#' @importFrom stats residuals
#' @importFrom kableExtra kable
#' @export
ARCH.test <- function(x, lags=10, format = NULL, round=3, demean=TRUE) {
if (is.vector(x) && isTRUE(demean)) {
# Store the name for display purposes
series_name <- deparse(substitute(x))
uhat <- (x-base::mean(x))^2
}else if (is.vector(x) && !isTRUE(demean)) {
series_name <- deparse(substitute(x))
uhat <- (x)^2
} else {
model.class <- class(x)[1]  # Get class of the model
# Extract residuals
uhat <- (switch(model.class,
"lm" = residuals(x),
"ardl" = residuals(x),
"dynlm" = residuals(x),
"arma" = residuals(x),
"ar" = residuals(x),
"dynardl" = x$model$residuals,
"MSM.lm" = MSwM::msmResid(x),
residuals(x)))^2  # Default to residuals() if class not matched
series_name <- "Model Residuals"
}
n <- length(uhat)
if (lags >= n) {
stop("lag must be less than the length of the series")
}
# Create vectors to store LM statistics and p-values
LM_stats <- numeric(lags)
p_values <- numeric(lags)
arch.test.Matrix <- stats::embed(x, lags)
# Calculate statistics for each lag from 1 to lag using FinTS::ArchTest
nlags <- 2:(lags+1)
for (p in nlags) {
matarch <- stats::embed(uhat, p)
arch.lm <- lm( matarch[,1]~matarch[,2:p] )
arch.lm.sum <- base::summary(arch.lm)
LM_stats[p] <- base::round(dim(arch.lm$model)[1]*arch.lm.sum$r.squared, round)
p_values[p] <- base::round(1 - stats::pchisq(LM_stats[p], df = dim(arch.lm.sum$coefficients)[1]-1 ), round)
}
arch.ac <- stats::acf(uhat, lag.max = lags, plot = FALSE)$acf
arch.ac <- base::round(arch.ac, round)
formatted_pvalues <- sapply(p_values, function(p) {
if (p < 0.001) {
"0.000"
} else {
format(round(p, round), nsmall = round)
}
})
# Create results matrix
result <- cbind(1:lags, arch.ac[-1], LM_stats[-1], formatted_pvalues[-1])
colnames(result) <- c("Lag", "AC", "ARCH-LM", "p-value")
if (is.null(format)) {
result <- kableExtra::kable(result, format = "rst", align = c("c", "r", "c", "c" ),
caption = "ARCH test")
} else{
#format <- match.arg(format)
result <- kableExtra::kable(result, format = format,
align = c("c", "r", "c", "c" ),
booktable = T, booktabs = T,
caption = "ARCH test")
}
#cat(sprintf("ARCH test based on %s", series_name))
invisible_stats <- list(
Lag = lags,
AC = arch.ac[lags+1],
ARCH.LM = LM_stats[lags],
p.value = p_values[lags]
)
class(invisible_stats) <- "htest"
return(result)
} ; ARCH.test(rnorm(98), lags = 2)
p <- ARCH.test(rnorm(98), lags = 2)
tsatoolkit::clearEnv("all")
tsatoolkit::ARCH.test(rnorm(43))
tsatoolkit::ARCH.test(rnorm(43))
devtools::document()
devtools::document()
devtools::document()
tsatoolkit::ARCH.LM.test(rnorm(7890))
tsatoolkit::Ljung.Box.test(rnorm(8907))
strrep(#, 2)
)
strrep("#",2)
cat(strrep("#",2))
length("###################################")
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
cat("e", greeks("rho"))
greeks("rho")
greekLetters::greeks("rho")
cat("e", greekLetters::greeks("rho"))
cat("e", " = ", greekLetters::greeks("rho"))
cat(greekLetters::greeks("rho"), " = ","e")
cat(greekLetters::greeks("rho"), "=","e")
cat(greekLetters::greeks("rho"),"=","e")
cat(greekLetters::greeks("rho"),"=","0")
cat(greekLetters::greeks("rho"),"=","0 :")
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report( cumsum(rnorm(43)+seq_along(rnorm(43))) )
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
class(rnorm(87))
if (ur.df.trend.results[3,1] < ur.df.trend.results[3,3] & ur.df.drift.results[2,1] < ur.df.drift.results[2,3] &
ur.df.none.results[1,1] > ur.df.none.results[1,3]) {
cat("Evidence of unit root", " * ", "\n")
}else if (ur.df.trend.results[3,1] < ur.df.trend.results[3,3] & ur.df.drift.results[2,1] < ur.df.drift.results[2,3] &
ur.df.none.results[1,1] < ur.df.none.results[1,3]) ) {
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(cumsum(rnorm(43)))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
-1.07 > -2
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
plot.ts(rnorm(43)+c(1:43))
get_lag_max <- function(n) {
if (n < 50) return(max(1, floor(n^(1/3))))
else if (n < 200) return(floor(4 * (n/100)^(1/4)))
else return(floor(12 * (n/100)^(1/4)))
}
get_lag_max(123)
get_lag_max(12355)
get_lag_max(12355555)
get_lag_max(12355555)/2
get_lag_max(12355555)*1/4
get_lag_max(123555559)*1/4
trunc(12 * (123445/100)^(1/4)),
trunc(12 * (123445/100)^(1/4))
floor(12 * (123445/100)^(1/4))
?tseries::adf.test()
trunc((123-1)^(1/3))
trunc((12993-1)^(1/3))
trunc((123555559-1)^(1/3))
trunc(12 * (123555559/100)^(1/4))
trunc(12 * (123555559/1000)^(1/4))
trunc(12 * (99/1000)^(1/4))
trunc(12 * (99/100)^(1/4))
trunc(12 * (99/100)^(1/3))
trunc(12 * (99/1000)^(1/3))
trunc(12 * (99/100)^(1/2))
trunc(12 * (99/100)^(1/4))
trunc(12 * (99/100)^(1/3))
trunc((99/100)^(1/3))
trunc((99)^(1/3))
trunc((99-1)^(1/3))
trunc((99-1)^(1/4))
trunc(12*(99-1)^(1/4))
trunc(12*(99/1)^(1/4))
trunc((99-1)^(1/3)))
trunc((99-1)^(1/3))
trunc((999-1)^(1/3))
trunc((9999-1)^(1/3))
trunc((99999-1)^(1/3))
trunc(12 * (99999/100)^(1/4))
trunc((length(Y)-1)^(1/3))
trunc((length(1:43)-1)^(1/3))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
?aTSA::adf.test()
floor(4*(99999/100)^(2/9))
floor(4*(99999/100)^(2/9))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(943)+c(1:943))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
tsatoolkit::ur.adf.report(rnorm(943)+c(1:943))
tsatoolkit::ur.adf.report(rnorm(9403)+c(1:9403))
2/9
2/6
2/11
3/11
2/11
2/10
floor(8*(43/100)^(2/9))
floor(12*(43/100)^(2/9))
floor(10*(43/100)^(2/9))
tsatoolkit::ur.adf.report(rnorm(943)+c(1:943))
tsatoolkit::ur.adf.report(rnorm(43)+c(1:43))
floor(10*(100/100)^(2/9))
10*(100/100)^(2/9)
10*(10/100)^(2/9)
floor(10*(10/100)^(2/9))
trunc(10*(10/100)^(2/9))
tsatoolkit::ur.adf.report(rnorm(943)+c(1:943))
tsatoolkit::ur.adf.report(rnorm(943)+c(1:943))
floor(10*(943/100)^(2/9))
floor(10*(943/100)^(2/8))
floor(10*(943/100)^(2/9.5))
floor(10*(943/100)^(2/11))
floor(10*(943/100)^(2/12))
floor(10*(943/100)^(2/18))
tsatoolkit::ur.adf.report(rnorm(9430)+c(1:9430))
tsatoolkit::ur.adf.report(rnorm(265)+c(1:265))
tsatoolkit::ur.adf.report(rnorm(265)+c(1:265))
tsatoolkit::ur.adf.report(cumsum(rnorm(265))+c(1:265))
tsatoolkit::ur.adf.report(cumsum(rnorm(265))+c(1:265))
tsatoolkit::ur.adf.report(cumsum(rnorm(65))+c(1:65))
tsatoolkit::ur.adf.report(cumsum(rnorm(65))+c(1:65))
tsatoolkit::ur.adf.report(cumsum(rnorm(65))+c(1:65))
tsatoolkit::ur.adf.report(cumsum(rnorm(65))+c(1:65))
tsatoolkit::ur.adf.report(cumsum(rnorm(65)))
tsatoolkit::ur.adf.report(rnorm(65))
tsatoolkit::ur.adf.report(rnorm(659))
tsatoolkit::ur.adf.report(rnorm(6599))
tsatoolkit::ur.adf.report( cumsum(rnorm(6599)) )
tsatoolkit::ur.adf.report( cumsum(rnorm(6599))+c(1:6599) )
tsatoolkit::ur.adf.report( cumsum(rnorm(6599))+c(1:6599)+runmed(6599) )
tsatoolkit::ur.adf.report( cumsum(rnorm(6599))+c(1:6599)+runif(6599) )
acf(cumsum(rnorm(6599))+c(1:6599)+runif(6599))
tsatoolkit::ur.adf.report( cumsum(rnorm(6599))+c(1:6599)+runif(6599) )
tsatoolkit::ur.adf.report( cumsum(rnorm(6599))+c(1:6599) )
tsatoolkit::tsDiagnostics(rnorm(987))
devtools::load_all()
tsatoolkit::tsDiagnostics(rnorm(987))
tsatoolkit::tsDiagnostics(rnorm(987))
tsatoolkit::tsDiagnostics(rnorm(987))
tsatoolkit::tsDiagnostics(c(NA,rnorm(987)))
tsatoolkit::tsDiagnostics(rnorm(987))
tsatoolkit::tsDiagnostics(c(NA,rnorm(987)))
tsatoolkit::tsDiagnostics(c(NA,rnorm(987)))
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
wooldridge::affairs
wooldridge::apple
wooldridge::econmath
econmath <- wooldridge::econmath[, c(score, work, colgpa, calculus, mathscr, age, male)]
econmath <- wooldridge::econmath[, c("score", "work", "colgpa", "calculus", "mathscr", age, "male")]
econmath <- wooldridge::econmath[, c("score", "work", "colgpa", "calculus", "mathscr", "age", "male")]
econmath
reg1 <- stats::lm.fit(econmath[, -1], econmath[, 1])
X <- as.matrix(econmath[, -1])
X
y <- as.matrix(econmath[, 1])
reg1 <- stats::lm.fit(X, y)
summary(reg1)
reg1
reg1$coefficients
stats::model.matrix.lm(reg1)
stats::model.matrix(reg1)
class(reg1)
names(econmath)
reg1 <- lm(score~work+colgpa+calculus+mathscr+age+male)
reg1 <- lm(score~work+colgpa+calculus+mathscr+age+male, data = econmath)
summary(reg1)
reg1 <- lm(score~work+colgpa+calculus+mathscr+age+male, data = econmath) ; summary(reg1)
mean(econmath$score)
stats::fitted.values(reg1)
stats::fitted(reg1)
plot.ts(stats::fitted.values(reg1))
reg1 <- lm(score~work+colgpa+calculus+mathscr+age+male, data = econmath) ; summary(reg1)
class(reg1)
reg1 <- dynlm::dynlm(score~work+colgpa+calculus+mathscr+age+male, data = econmath) ; summary(reg1)
reg1 <- lm(score~work+colgpa+calculus+mathscr+age+male, data = econmath) ; summary(reg1)
reg1$coefficients
NCOL(reg1$coefficients)
length(reg1$coefficients)
dim(reg1$coefficients)
stats::model.matrix(reg1)
dim(stats::model.matrix(reg1))
dim(stats::model.matrix(reg1))[1]
dim(stats::model.matrix(reg1))[2]
devtools::document()
devtools::document()
tsatoolkit::white.test(reg1)
tsatoolkit::white.test(reg1)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
tsatoolkit::white.test(reg1, summary = T)
is(reg1)
oldClass(reg1)
dynts <- dynlm::M1Germany
dynreg <- dynlm::(logprice~logm1+loggnp+interest, data=dynts)
dynreg <- dynlm::dynlm(logprice~logm1+loggnp+interest, data=dynts)
dynreg <- dynlm::dynlm(logprice~logm1+loggnp+interest, data = dynts)
dynts
library(zoo)
# Puis utiliser dynlm
dynreg <- dynlm::dynlm(logprice ~ logm1 + loggnp + interest, data = dynts)
library(zoo)
# Puis utiliser dynlm
dynreg <- dynlm::dynlm(logprice ~ logm1 + loggnp + interest, data = dynts) ; summary(dynreg)
oldClass(dynreg)
list(oldClass(dynreg))
as.vector(oldClass(dynreg))
list(as.vector(oldClass(dynreg)))
fitted.values(dynreg)
tsatoolkit::white.test(dynreg, summary = T)
plot.ts(fitted.values(dynreg))
tsatoolkit::white.test(dynreg, summary = T)
tsatoolkit::white.test(dynreg, summary = T)
tsatoolkit::white.test(dynreg, summary = T)
tsatoolkit::white.test(dynreg, summary = T)
tsatoolkit::white.test(dynreg, summary = T)
